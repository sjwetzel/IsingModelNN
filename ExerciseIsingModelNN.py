# -*- coding: utf-8 -*-
"""
Created on Wed Aug 16 06:38:36 2023

@author: sebastian j. wetzel
"""


"""
In this python script, we build a simple artificial neural network with one hidden layer from scratch.
This artificial neural network is then applied to predict the critical temperature of the Ising Model 
on the square lattice Tc=2.269.

We implement forward passes and backpropagation for a neural network with one hidden layer using sigmoid
activation functions and the Mean Squared Error Loss Function (MSE). We also implement a change of the loss function
to the Binary Cross Entropy Loss (CE)

In order to predict the critical temperature, we assume we know the phases in the high and low temperature
limits, ie ferromagnetism at low T and paramagnetism at high T. We load a dataset of Ising Model configurations
generated by a Monte-Carlo algorithm and divide the data into three parts, the low T data, the high T data and
the unknown intermediate T data.

We train the neural network on high and low temperature to predict the phases: ferromagnetic[1] or paramagnetic[0].
After successful training we evaluate the predictions of the neural network in the intermediate temperature range.
We can observe a sharp change at a certain temperature which indicates our prediction for the critical temperature Tc.  
"""


"""
In this first part we import some libraries, define some functions we need later
"""
import numpy as np
import matplotlib.pyplot as plt


# Define the sigmoid activation function and its derivative
def sigmoid(x):
    return 1 / (1 + np.exp(-x))


# The sigmoid derivative is stated as a function of sigmoids s=sigmoid(x)
def sigmoid_derivative(s):
    return s * (1 - s)



"""
In this part we load the data set and create the training set
"""

# Import Data Set
npzfile = np.load('IsingConfigurations.npz')
Temperatures=npzfile['Temperatures']
Configurations_square_lattice=npzfile['Configurations']


# Visualize configuratins belonging to different phases
plt.imshow(Configurations_square_lattice[50,0], cmap='binary', interpolation='nearest')
plt.title('Ferromagnetism')
plt.colorbar()
plt.show()

plt.imshow(Configurations_square_lattice[100,0], cmap='binary', interpolation='nearest')
plt.title('Unknown')
plt.colorbar()
plt.show()

plt.imshow(Configurations_square_lattice[150,0], cmap='binary', interpolation='nearest')
plt.title('Paramagnetism')
plt.colorbar()
plt.show()


# We reshape the data from square lattice to a single vector such that we can feed it to a fully connected neural network
Configurations=Configurations_square_lattice.reshape(Configurations_square_lattice.shape[0],Configurations_square_lattice.shape[1],-1)

### there are 200 temperature bins, how many of these should be used on either side for training?
T_boundaries=50       
T_Low=Temperatures[:T_boundaries]
T_High=Temperatures[200-T_boundaries:]
T_Test=Temperatures[T_boundaries:200-T_boundaries]

X_low=Configurations[:T_boundaries]
X_high=Configurations[200-T_boundaries:]
X_test=Configurations[T_boundaries:200-T_boundaries]

X_train=np.concatenate([X_low.reshape(T_boundaries*X_low.shape[1],-1),X_high.reshape(T_boundaries*X_high.shape[1],-1)],axis=0)
y_train=np.concatenate([np.ones(T_boundaries*len(Configurations[0])),np.zeros(T_boundaries*len(Configurations[0]))],axis=0).reshape(-1, 1)

num_samples = len(X_train)


"""
In this part we create the neural network, we adjust some hyperparameters and create a training routine
"""

# Set hyperparameters of a network with one hidden layer
input_size = 400
hidden_size = 20
output_size = 1
learning_rate = 0.1
batch_size = 32
epochs = 1000

# Initialize weights and biases randomly
weights_input_hidden = np.random.uniform(size=(input_size, hidden_size))
biases_hidden = np.random.uniform(size=(1, hidden_size))
""" TASK 1:  initialize random weights and biases of the output neuron """
weights_hidden_output = ...
biases_output = ...

# Make predictions, this implements a forward pass 
def NN_prediction(x):
    ### check for x to have correct dimensions
    new_hidden_layer_input = np.dot(x, weights_input_hidden) + biases_hidden
    new_hidden_layer_output = sigmoid(new_hidden_layer_input)
    new_output_layer_input = np.dot(new_hidden_layer_output, weights_hidden_output) + biases_output
    new_predicted_output = sigmoid(new_output_layer_input)
    return new_predicted_output


# Training loop
for epoch in range(epochs):
    perm=np.random.permutation(len(X_train))
    X_train=X_train[perm]
    y_train=y_train[perm]
    # instantiate training MSE for each epoch
    MSE_train=0
    for batch_start in range(0, num_samples, batch_size):
        batch_end = batch_start + batch_size
        X_batch = X_train[batch_start:batch_end]
        y_batch = y_train[batch_start:batch_end]
        
        # Forward propagation
        """TASK 2: implement the forward pass of the neural network explicitly, note that it applies to the minibatch X_batch"""
        hidden_layer_input = ...
        hidden_layer_output = ...
        output_layer_input = ...
        predicted_output = ...
        
        
        """TASK 3: The following part contains the backpropagation algorithm using the MSE loss function.
            STEP 1: Run the code, 
            STEP 2: Rewrite the backpropagation algorithm using the cross entropy loss function, for this
                    you need to perform a calculation by hand to see what changes
            STEP 3: Run the code and observe the training MSE convergence, compare that to STEP 1
        """
        # Calculate the error, you can absorb any prefactors in the learning_rate
        error = predicted_output - y_batch 
        
        # Backpropagation
        d_predicted_output = error * sigmoid_derivative(predicted_output)         # this line is from the MSE loss
        error_hidden_layer = d_predicted_output.dot(weights_hidden_output.T)
        d_hidden_layer = error_hidden_layer * sigmoid_derivative(hidden_layer_output)
        
        # Update weights and biases
        weights_hidden_output -= hidden_layer_output.T.dot(d_predicted_output) * learning_rate
        biases_output -= np.sum(d_predicted_output, axis=0, keepdims=True) * learning_rate
        weights_input_hidden -= X_batch.T.dot(d_hidden_layer) * learning_rate
        biases_hidden -= np.sum(d_hidden_layer, axis=0, keepdims=True) * learning_rate
        
        # Calculate MSE
        MSE_train+=np.sum(error**2)/len(X_train)
    
    print('Training MSE:',MSE_train)
    print('Epoch:', epoch)



"""
Finally, we apply the trained neural network to the remaining Ising configurations to reveal the phase transition
"""

# Apply NN to Ising Model Samples
av_prediction_per_temperature=[ np.average(NN_prediction(configs)) for configs in Configurations ]

plt.scatter(Temperatures[:T_boundaries],av_prediction_per_temperature[:T_boundaries],label='Low T\nTraining Set')
plt.scatter(Temperatures[200-T_boundaries:],av_prediction_per_temperature[200-T_boundaries:],label='High T\nTraining Set')
plt.scatter(Temperatures[T_boundaries:200-T_boundaries],av_prediction_per_temperature[T_boundaries:200-T_boundaries],label='Intermediate T\nTest Set')
plt.vlines(2.269,0,1,label='True Tc',linestyles='dashed')
plt.legend(loc='upper right')

plt.title('2D Ising Model NN Prediction vs Temperature')
plt.show()
